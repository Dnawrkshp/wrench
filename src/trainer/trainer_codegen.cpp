/*
	wrench - A set of modding tools for the Ratchet & Clank PS2 games.
	Copyright (C) 2019-2025 chaoticgd

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#include <functional>
#include <set>

#include <core/build_config.h>
#include <core/filesystem.h>
#include <cppparser/cpp_parser.h>

// This code merges data types from a number of different files, each file
// corresponding to a different game, into a single file where types with the
// same name are merged into single classes, thus enabling me to write code that
// works with all the games.

static void generate_header();
static void generate_implementation();
static void for_each_type(std::function<void(const std::string&)> callback);
static void for_each_field(const std::string& type_name, std::function<void(const CppType* field[MAX_GAME])> callback);
static void out(const char* format, ...);

static WrenchFileHandle* s_out_handle = NULL;

int main(int argc, char** argv)
{
	if (argc != 6) {
		fprintf(stderr, "usage: %s <rac types path> <gc types path> <uya types path> <dl types path> <output path>\n",
			(argc > 0) ? argv[0] : "trainer_codegen");
		return 1;
	}
	
	s_out_handle = file_open(argv[5], WRENCH_FILE_MODE_WRITE);
	verify(s_out_handle, "Failed to open output file.");
	
	struct InputPath
	{
		Game game;
		fs::path path;
	};
	
	InputPath input_paths[] = {
		{Game::RAC, argv[1]},
		{Game::GC, argv[2]},
		{Game::UYA, argv[3]},
		{Game::DL, argv[4]}
	};
	
	fs::path output_path(argv[5]);
	
	out("// Generated by trainer_codegen. Do not edit.");
	out("");
	out("namespace remote {");
	out("");
	generate_header();
	out("");
	generate_implementation();
	out("");
	out("}");
	
	file_close(s_out_handle);
}

static void generate_header()
{
	out("#ifdef GENERATED_TRAINER_TYPES_HEADER");
	out("");
	
	for_each_type([&](const std::string& type_name) {
		out("class %s;", type_name.c_str());
	});
	out("");
	
	for_each_type([&](const std::string& type_name) {
		out("class %s", type_name.c_str());
		out("{");
		out("};");
	});
	
	out("#endif");
	out("");
}

static void generate_implementation()
{
	out("#ifdef GENERATED_TRAINER_TYPES_IMPLEMENTATION");
	out("");
	
	
	out("#endif");
	out("");
}

static void for_each_type(std::function<void(const std::string&)> callback)
{
	//std::set<std::string> visited;
	//for (GameTypes& game_types : s_games) {
	//	for (const auto& type : game_types.types) {
	//		if (!visited.contains(type.first)) {
	//			callback(type.first);
	//			visited.emplace(type.first);
	//		}
	//	}
	//}
}

static void for_each_field(const std::string& type_name, std::function<void(const CppType* field[MAX_GAME])> callback)
{
	//std::set<std::string> visited;
	//for (GameTypes& game_types : s_games) {
	//	auto iter = game_types.types.find(type_name);
	//	if (iter == game_types.types.end()) {
	//		continue;
	//	}
	//	
	//	const CppType& type = iter->second;
	//}
}

static void out(const char* format, ...)
{
	va_list list;
	va_start(list, format);
	file_vprintf(s_out_handle, format, list);
	file_write("\n", 1, s_out_handle);
	va_end(list);
}
